const { OFFLINE, SIMULATING } = require("../DeviceStatus");
const { EventSchema, ReportSchema } = require("../enact-mongoose");
const {
  evalulate, THRESHOLD_FLEXIBLE, ALL_EVENTS, METRIC_VALUE_TIMESTAMP,
} = require("../evaluation");
const Thing = require("../things/Thing");

/**
 * Simulation class presents a simulation
 */
class Simulation {
  constructor(model, options = null, simulationCallbackWhenFinish = null) {
    this.model = model;
    this.newDataset = model.newDataset;
    this.dataStorage = model.dataStorage;
    this.datasetId = model.datasetId;
    this.replayOptions = model.replayOptions;
    this.testCampaignId = model.testCampaignId;
    this.evaluationParameters = model.evaluationParameters;
    this.simulationCallbackWhenFinish = simulationCallbackWhenFinish;
    this.status = OFFLINE;
    if (options) {
      // Overwrite the value of datastorage, datasetid and new dataset
      if (options.dataStorage) this.dataStorage = options.dataStorage;
      if (options.datasetId) this.datasetId = options.datasetId;
      if (options.replayOptions) this.replayOptions = options.replayOptions;
      if (options.newDataset) this.newDataset = options.newDataset;
      if (options.testCampaignId) this.testCampaignId = options.testCampaignId;
      if (options.evaluationParameters) this.evaluationParameters = options.evaluationParameters;
    }
    if (!this.evaluationParameters) {
      console.log(`[SIMULATION] Use default evaluation parameters`);
      this.evaluationParameters = {
        threshold: THRESHOLD_FLEXIBLE,
        eventType: ALL_EVENTS,
        metricType: METRIC_VALUE_TIMESTAMP
      }
    }

    // Create the dataset if needed
    const currentTime = Date.now();
    if (!this.newDataset) {
      // use a template for dataset -> all the simulated data should be stored in the data storage
      this.newDataset = {
        id: `data-set-${currentTime}`,
        name: `Dataset of model ${model.name} (${currentTime})`,
        description: `Dataset Generated by model ${
          model.name
        } at time ${new Date(currentTime).toLocaleTimeString()}`,
        tags: ["auto-created"],
        lastModified: currentTime,
        source: "GENERATED",
      };
    } else {
      this.newDataset["lastModified"] = currentTime;
      if (!this.newDataset["source"]) this.newDataset["source"] = "GENERATED";
    }

    // Generate the report
    const currenTime = Date.now();
    let startTime = 0;
    let endTime = currenTime;
    if (this.replayOptions) {
      if (this.replayOptions.startTime)
        startTime = this.replayOptions.startTime;
      if (this.replayOptions.endTime) endTime = this.replayOptions.endTime;
    }
    const reportId = `${this.datasetId}-${this.newDataset.id}-${currentTime}`;
    this.report = {
      id: reportId,
      testCampaignId: this.testCampaignId,
      topologyFileName: `${model.name}.json`,
      originalDatasetId: this.datasetId,
      newDatasetId: this.newDataset.id,
      createdAt: currenTime,
      startTime: startTime,
      endTime: endTime,
      score: -1,
      evaluationParameters: this.evaluationParameters,
    };

    this.allThings = [];
  }

  deviceCallbackWhenFinish() {
    console.log("A device is going to finish his job");
    for (let index = 0; index < this.allThings.length; index++) {
      const dev = this.allThings[index];
      if (dev.status !== OFFLINE) {
        return;
      }
    }
    const stopSimulation = (score) => this.stop(score);
    // Going to evaluate the report here
    const {
      id,
      originalDatasetId,
      newDatasetId,
      startTime,
      endTime,
    } = this.report;
    EventSchema.findEventsBetweenTimes(
      { datasetId: originalDatasetId },
      startTime,
      endTime,
      (err3, originalEvents) => {
        if (err3) {
          console.error(
            `Cannot get original events of dataset ${originalDatasetId}`
          );
          stopSimulation();
        } else {
          EventSchema.findEventsWithOptions(
            { datasetId: newDatasetId },
            (err4, newEvents) => {
              if (err4) {
                console.error(
                  `Cannot get new events of dataset ${newDatasetId}`
                );
                stopSimulation();
              } else {
                const {threshold, eventType, metricType} = this.evaluationParameters;
                const score = evalulate(
                  originalEvents,
                  newEvents,
                  eventType,
                  metricType,
                  threshold
                );
                // Going to save the score into the report
                ReportSchema.findOneAndUpdate(
                  { id },
                  { score },
                  (err5, ret) => {
                    if (err5) {
                      console.error(`Cannot update the score for report ${id}`);
                      stopSimulation();
                    } else {
                      console.log(`Report ${id} has score of ${score}`);
                      stopSimulation(score);
                    }
                  }
                );
              }
            }
          );
        }
      }
    );
  }

  createDevice(devConfig, isFirstDevice = false) {
    const newThing = new Thing(
      devConfig,
      this.dataStorage,
      this.datasetId,
      this.replayOptions,
      this.newDataset,
      this.report,
      isFirstDevice,
      () => this.deviceCallbackWhenFinish()
    );

    newThing.initDevice(() => {
      newThing.start();
      this.allThings.push(newThing);
    });
  }

  start() {
    console.log("Start simulating for the model: ", this.model.name);
    this.status = SIMULATING;
    while (this.allThings.length > 0) {
      this.allThings.pop();
    }
    const { devices } = this.model;
    for (let index = 0; index < devices.length; index++) {
      const dev = devices[index];
      const { id, name, scale, enable } = dev;
      if (enable === false) continue; // skip this device
      let nbDevices = scale ? scale : 1;
      if (nbDevices === 1) {
        this.createDevice(dev, index === 0);
        // NOTE: All the information in the model will be transfer to each Device -> better in the future if we want to improve the performance by parallel the process
      } else {
        for (let tIndex = 0; tIndex < nbDevices; tIndex++) {
          const tID = `${id}-${tIndex}`;
          const tName = `${name}-${tIndex}`;
          this.createDevice(
            {
              ...dev,
              id: tID,
              name: tName,
            },
            index === 0 && tIndex === 0
          );
        }
      }
    }
  }

  /**
   * Stop the simulation
   */
  stop(score) {
    if (this.status === OFFLINE) {
      console.log("Simulation has been stopped already");
    } else {
      this.status = OFFLINE;
      for (let index = 0; index < this.allThings.length; index++) {
        const th = this.allThings[index];
        if (th.status !== OFFLINE) th.stop();
      }

      if (this.simulationCallbackWhenFinish)
        this.simulationCallbackWhenFinish(score);
    }
  }

  getStats() {
    const stats = [];
    if (!this.allThings) return null;
    for (let index = 0; index < this.allThings.length; index++) {
      const thing = this.allThings[index];
      const thingStats = thing.getStats();
      if (thingStats) stats.push(thingStats);
    }
    return stats;
  }
}

module.exports = Simulation;
